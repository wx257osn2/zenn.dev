---
title: "量子コンピュータで“Covert”なガチャ⁉️"
emoji: "🙈"
type: "tech"
topics: ["量子コンピュータ", "暗号"]
published: false
---

# はじめに

“_Covert Lottery_” とは論文[Card-Based Covert Lottery](https://doi.org/10.1007/978-3-030-69255-1_17)[^original]で導入された用語である。これはプレイヤーの秘密の希望を入力し、

1. それらが衝突しないのであれば希望通りにし
2. そうでないなら、ランダムな結果を出力する

というプロトコルである。たとえば将棋などで2人のプレイヤーが先手・後手を決める場合に使うことができる。この2人のプレイヤーはそれぞれ先手・後手のどちらにしたいという希望があるものとするが、一方でこの希望を相手に明らかにしてしまうと、戦略が流出する可能性がある。したがってこのプレイヤー2人がCovert Lotteryを行えば、各々の希望が先手・後手の希望が噛み合った（衝突していない）時にはそれを出力し、一方で2人ともが先手・後手のいずれかを希望した場合はランダムに決定する。このようにすれば2人のプレイヤーは自分の入力した希望通りとなったのか、それとも衝突してランダムに決定されたのか知ることができないため、戦略が流出しない。
元論文ではこのようなプロトコルをカードベース暗号で構成しているが、筆者が軽く読んだ限りでは量子コイントスでも達成できそうであったため、この記事では量子コイントスでこれをどのように達成するかについて議論する。
この記事にもし何かの誤りがあったとしてもこの記事の筆者の落ち度であるので、コメントなどで気軽に教えてほしい。

[^original]: この論文のことを今後は「元論文」という呼ぶことにする。

# 2人のCovert Lotteryを行う関数$\mathcal{F}$

この節では元論文で説明されている2人のCovert Lottery（先手・後手を秘密に決定する）についてまず説明する。
いま2人のプレイヤーとしてアリスとボブがいるものとする。アリスの入力を$a$として、アリスが先手を希望するならならば$a = 1$となり、後手を希望するなら$a = 0$となる。ボブについても同様に先手を希望するなら$b = 1$であり、後手を希望するなら$b = 1$とする。つまり先手なら$1$、後手なら$0$というエンコードになっている。
そして$\mathcal{F}$を「アリスの先手・後手を出力する関数」であるとすると、次のようになる。

$$
\mathcal{F}(a, b) := \left\{
  \begin{array}{lr}
    a & \text{if}\; a \ne b \\
    i \xleftarrow{\text{rnd}} \{0, 1\} & \text{if}\; a = b
  \end{array}
\right.
$$

ただし$\xleftarrow{\text{rnd}} \{0, 1\}$は$\{0, 1\}$からランダムに片方を選ぶことを意味している[^rnd]。

[^rnd]: 論文では矢印の上に`$`（LaTeX表記では`\xleftarrow{\text{$}}`）の記号を利用してランダムを表現しているが、Zennのパーザーの都合（？）でこの表記が数式として認められなかったため表記を変更した。

議論の前に、この後すぐに使うので先に表記として$\overline{x}$を導入しておく。これは$x \in \{0,1\}$にNOT演算を適用した結果を意味している。たとえば$x = 0$であれば$\overline{x} = 1$となる。

さて、この関数$\mathcal{F}$について考える。今もし$a \ne b$であったとしたら、$a, b \in \{0, 1\}$であるから、$a = \overline{b}$となる。逆に$a = b$であれば$\{a, \overline{b}\} = \{0, 1\}$である。この2つをまとめると$\mathcal{F}$を次のように書き直せる。


$$
\mathcal{F}(a, b) = \left\{
  \begin{array}{lr}
    a\, (= \overline{b}) & \text{if}\; a \ne b \\
    i \xleftarrow{\text{rnd}} \{a, \overline{b}\} & \text{if}\; a = b
  \end{array}
\right.
$$

ここで$a \ne b$のケースは実は$a = \overline{b}$なため、$\{a, \overline{b}\}$からどちらかを選んだ結果と等しくなる。そのためもはやこの場合分けは不要となり$\mathcal{F}$は次のようになる。

$$
\mathcal{F}(a, b) = r \xleftarrow{\text{rnd}} \{a, \overline{b}\}
$$

元論文では、$a, b$を秘密にしたままこのような関数$\mathcal{F}$をカードプロトコルで構成していた。その説明が気になる人は元論文を入手してもらうとして、ここでは量子コンピュータを利用した方法を紹介する。

# 量子コンピュータによる関数$\mathcal{F}$の実装

aaaa

$$
\def\bra#1{\mathinner{\left\langle{#1}\right|}}
\def\ket#1{\mathinner{\left|{#1}\right\rangle}}
\def\braket#1#2{\mathinner{\left\langle{#1}\middle|#2\right\rangle}}
\begin{align}
\left\{
  \begin{array}{l}
    \ket{\psi_{0,0}} \equiv \ket{0} \\
    \ket{\psi_{0,1}} \equiv \ket{1} \\
    \ket{\psi_{1,0}} \equiv \ket{+} \\
    \ket{\psi_{1,1}} \equiv \ket{-}
  \end{array}
\right.& \\
       &\text{where}\; \ket{\pm} \equiv \frac{1}{\sqrt{2}}\left(\ket{0} \pm \ket{1}\right)
\end{align}
$$

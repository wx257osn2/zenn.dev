---
title: "量子コンピュータで“Covert”⁉️な1bitガチャ"
emoji: "🙈"
type: "tech"
topics: ["量子コンピュータ", "暗号", "セキュリティ"]
published: false
---

# はじめに

“_Covert Lottery_” とは論文[Card-Based Covert Lottery](https://doi.org/10.1007/978-3-030-69255-1_17)[^original]で導入された用語である。これはプレイヤーの秘密の希望を入力し、

1. それらが衝突しないのであれば希望通りにし
2. そうでないなら、ランダムな結果を出力する

というプロトコルである。たとえば将棋などで2人のプレイヤーが先手・後手を決める場合に使うことができる。この2人のプレイヤーはそれぞれ先手・後手のどちらにしたいという希望があるものとするが、一方でこの希望を相手に明らかにしてしまうと、戦略が流出する可能性がある。したがってこのプレイヤー2人がCovert Lotteryを行えば、各々の希望が先手・後手の希望が噛み合った（衝突していない）時にはそれを出力し、一方で2人ともが先手・後手のいずれかを希望した場合はランダムに決定する。このようにすれば2人のプレイヤーは自分の入力した希望通りとなったのか、それとも衝突してランダムに決定されたのか知ることができないため、戦略が流出しない。
元論文ではこのようなプロトコルをカードベース暗号[^card_base_crypto]で構成しているが、筆者が軽く読んだ限りでは量子コイントスでも達成できそうであったため、この記事では量子コイントスでこれをどのように達成するかについて議論する。
この記事にもし何かの誤りがあったとしてもこの記事の筆者の落ち度であるので、コメントなどで気軽に教えてほしい。

[^original]: この論文のことを今後は「元論文」という呼ぶことにする。

[^card_base_crypto]: この文書を読むうえではカードベース暗号の知識は必要ないが、これはこれで非常におもしろいので、たとえば[カード組を用いた秘密計算](https://doi.org/10.1587/essfr.9.3_179)といった文献を読むとよい。

# 2人のCovert Lotteryを行う関数

この節では元論文で説明されている2人のCovert Lottery（先手・後手を秘密に決定する）についてまず説明する。
いま2人のプレイヤーとしてアリスとボブがいるものとする。アリスの入力を$a$として、アリスが先手を希望するならならば$a = 1$となり、後手を希望するなら$a = 0$となる。ボブについても同様に先手を希望するなら$b = 1$であり、後手を希望するなら$b = 1$とする。つまり先手なら$1$、後手なら$0$というエンコードになっている。
そして$\mathcal{F}$を「アリスの先手・後手を出力する関数」であるとすると、次のようになる。

$$
\mathcal{F}(a, b) := \left\{
  \begin{array}{lr}
    a & \text{if}\; a \ne b \\
    i \xleftarrow{\text{rnd}} \{0, 1\} & \text{if}\; a = b
  \end{array}
\right.
$$

ただし$\xleftarrow{\text{rnd}} \{0, 1\}$は$\{0, 1\}$からランダムに片方を選ぶことを意味している[^rnd]。

[^rnd]: 論文では矢印の上に`$`（LaTeX表記では`\xleftarrow{\text{$}}`）の記号を利用してランダムを表現しているが、Zennのパーザーの都合（？）でこの表記が数式として認められなかったため表記を変更した。

議論の前に、この後すぐに使うので先に表記として$\overline{x}$を導入しておく。これは$x \in \{0,1\}$にNOT演算を適用した結果を意味している。たとえば$x = 0$であれば$\overline{x} = 1$となる。

さて、この関数$\mathcal{F}$について考える。今もし$a \ne b$であったとしたら、$a, b \in \{0, 1\}$であるから、$a = \overline{b}$となる。逆に$a = b$であれば$\{a, \overline{b}\} = \{0, 1\}$である。この2つをまとめると$\mathcal{F}$を次のように書き直せる。


$$
\mathcal{F}(a, b) = \left\{
  \begin{array}{lr}
    a\, (= \overline{b}) & \text{if}\; a \ne b \\
    i \xleftarrow{\text{rnd}} \{a, \overline{b}\} & \text{if}\; a = b
  \end{array}
\right.
$$

ここで$a \ne b$のケースは実は$a = \overline{b}$なため、$\{a, \overline{b}\}$からどちらかを選んだ結果と等しくなる。そのためもはやこの場合分けは不要となり$\mathcal{F}$は次のようになる。

$$
\mathcal{F}(a, b) = r \xleftarrow{\text{rnd}} \{a, \overline{b}\}
$$

元論文では、$a, b$を秘密にしたままこのような関数$\mathcal{F}$をカードプロトコルで構成していた。その説明が気になる人は元論文を入手してもらうとして、ここでは量子コンピュータを利用した方法を紹介する。

# 量子コンピュータによる2人のCovert Lottery

それでは実際に量子コンピュータを利用したプロトコルについて説明する[^quantum_intro]。今、アリスとボブの2人が先手・後手を決めたいと考えている。前節と同様に$1$を先手、$0$を後手として次のようなプロトコルを実行する。

[^quantum_intro]: この記事では量子コンピュータの基本的な演算を前提としている。このあたりに自身がない場合は拙著の[量子コンピュータを利用した公平なガチャ#古典計算機と量子コンピュータ](https://qiita.com/yyu/items/efcf471ce9b97e885957#%E5%8F%A4%E5%85%B8%E8%A8%88%E7%AE%97%E6%A9%9F%E3%81%A8%E9%87%8F%E5%AD%90%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF)などを参考にしてほしい。

1. アリスは1bitの乱数$x \xleftarrow{\text{rnd}} \{0, 1\}$と、先手・後手の希望$a$を選択する
2. アリスは$a, x$を用いて次の4つ量子状態から1つ$\ket{\psi_{a,x}}$を選択する

    $$
    \def\bra#1{\mathinner{\left\langle{#1}\right|}}
    \def\ket#1{\mathinner{\left|{#1}\right\rangle}}
    \def\braket#1#2{\mathinner{\left\langle{#1}\middle|#2\right\rangle}}
    \begin{align*}
    \left\{
      \begin{array}{l}
        \ket{\psi_{0,0}} \equiv \ket{0} \\
        \ket{\psi_{0,1}} \equiv \ket{1} \\
        \ket{\psi_{1,0}} \equiv \ket{+} \\
        \ket{\psi_{1,1}} \equiv \ket{-}
      \end{array}
    \right.& \\
           &\text{where}\; \ket{\pm} \equiv \frac{1}{\sqrt{2}}\left(\ket{0} \pm \ket{1}\right)
    \end{align*}
    $$
3. アリスはボブへ量子ビット$\ket{\psi_{a,x}}$を送信する
4. ボブは量子状態$\ket{\psi_{a,x}}$を受信し、ボブの希望$b \in \{0, 1\}$を選択する
5. ボブは次のような基底状態$\mathcal{B}_{\overline{b}}$で$\ket{\psi_{a,x}}$を測定し、測定結果を$y$とする

    $$
    \mathcal{B}_{\overline{b}} \equiv \left\{\ket{\psi_{\overline{b},0}}, \ket{\psi_{\overline{b},1}}\right\}
    $$
    - $\overline{b}$を利用することに注意する
6. ボブはアリスへ$y$を送信する
7. アリスは$y$を受けとり、$a \oplus x \oplus y$[^oplus]をボブへ送信しプロトコルの結果とする

[^oplus]: $\oplus$はXOR演算を表す。

このプロトコルだけ見せられても実際に正しく動作しているのかよく分からないと思うので、アリスの変数$a, x$とボブの変数$b$について$y$や$a \oplus x \oplus y$がどうなるのか？というのを次の表にまとめた。


| $a$         | $x$ | $\ket{\psi_{a,x}}$ | $\overline{b}$ | $\mathcal{B}_{\overline{b}}$       |                  $y$                 |         $a \oplus x \oplus y$        |
|-------------|-----|--------------------|----------------|------------------------------------|:------------------------------------:|:------------------------------------:|
| $0$（後手） | $0$ | $\ket{0}$          | $0$（先手）    | $\left\{\ket{0}, \ket{1}\right\}$  |                  $0$                 |                  $0$                 |
| $0$（後手） | $0$ | $\ket{0}$          | $1$（後手）    | $\left\{\ket{+}, \ket{-}\right\}$  | $r \xleftarrow{\text{rnd}} \{0, 1\}$ | $r \xleftarrow{\text{rnd}} \{0, 1\}$ |
| $0$（後手） | $1$ | $\ket{1}$          | $0$（先手）    | $\left\{\ket{0}, \ket{1}\right\}$  |                  $1$                 |                  $0$                 |
| $0$（後手） | $1$ | $\ket{1}$          | $1$（後手）    | $\left\{\ket{+}, \ket{-}\right\}$  | $r \xleftarrow{\text{rnd}} \{0, 1\}$ | $r \xleftarrow{\text{rnd}} \{0, 1\}$ |
| $1$（先手） | $0$ | $\ket{+}$          | $0$（先手）    | $\left\{\ket{0}, \ket{1}\right\}$  | $r \xleftarrow{\text{rnd}} \{0, 1\}$ | $r \xleftarrow{\text{rnd}} \{0, 1\}$ |
| $1$（先手） | $0$ | $\ket{+}$          | $1$（後手）    | $\left\{\ket{+}, \ket{-}\right\}$ |                  $0$                 |                  $1$                 |
| $1$（先手） | $1$ | $\ket{-}$          | $0$（先手）    | $\left\{\ket{0}, \ket{1}\right\}$ | $r \xleftarrow{\text{rnd}} \{0, 1\}$ | $r \xleftarrow{\text{rnd}} \{0, 1\}$ |
| $1$（先手） | $1$ | $\ket{-}$          | $1$（後手）    | $\left\{\ket{+}, \ket{-}\right\}$ |                  $1$                 |                  $1$                 |

このようにアリスとボブの先手・後手の希望が異なる時に限って最終的な出力$a \oplus x \oplus y$がアリスの先手・後手を示すようになっている。
なぜこのようになるのか？そのアイディアをまとめると

- $a = \overline{b}\,(\Rightarrow a \ne b)$のときは（5）の測定結果$y$はアリスの乱数$x$と必ず一致する
    - 一方で$a \ne \overline{b}$のときは$y$が乱数になるため、$a \oplus x \oplus y$は最終的に乱数とXORするので乱数となりOKである
- $a = \overline{b}$なときは$x = y$なので、したがって$a \oplus x \oplus y$のXORはキャンセルされて$a$が計算される

## このプロトコルの問題点

このプロトコルでは（7）で最後にアリスの手元で行なわれる計算が最終的な結果となるため、アリスが不誠実であればここで結果を意図的に変更できる。したがってこれは少なくともアリスがセミオネスト[^semi-honest]であるという仮定の下でしか上手くいかない。

[^semi-honest]: プレイヤーが「セミオネスト（_semi-honest_）」であるとき、このプレイヤーはプロトコルの指示には違反しないが、プロトコルの指示に従う限りで（できるなら）他プレイヤーの情報を奪うといった不誠実な振る舞いをする。


# Covert Lotteryとガチャ

元論文でもCovert Lotteryと呼ばれているように、これは先手・後手の決定とは別にくじに使うことができる。元論文ではこの2人のCovert Lotteryを任意の多人数へ拡張して次のような説明をしている。

- $n$人の$P_1, \dots P_n$参加者が$m$個の景品$I_1, \dots, I_m$のうちいくつか（0個もOK）が欲しいと考えている
- 景品$I_i$について、プレイヤーは$0$または$1$を投票する
- このとき
    1. もし1人のプレイヤー$P_j$のみが$1$を投票し、それ以外の全プレイヤーが$0$を投票していれば$P_j$が景品$I_i$を入手する
    2. 一方で複数のプレイヤーが$1$を投票した場合は、そのプレイヤーの中からランダムに1人を決定する

つまり、2人のCovert Lotteryも上記のように考えると、2人のプレイヤーにおいて次のようになる。

- どちらか1人のみ景品が欲しい場合はそちらに景品が当選する
- 2人ともが景品が欲しい・欲くない場合はランダムに当選者が選択される

つまり複数のプレイヤー間で、プレイヤーの希望を隠蔽したまま景品をなるべく希望に沿う形で当選させることができる。たとえば欲しくない景品が当選したので転売するといったことはあるだろうと思うので、そういったことをなるべく少なくできるかもしれない。

# まとめ

アリスがセミオネストであるという仮定をなんとか取り除けないか多少は考えたものの、すぐには思いつかなかったのでいったんこのままで公開することにした。もしよい方法を思いついたという方がいれば教えてほしい。
また元論文では今回紹介した2人のプロトコルを任意の人数へ拡張していたため、そちらも量子プロトコルで達成できないか？というのを考えていきたい。

# 謝辞

元論文を教えてくれた[@mimizunohimono](https://twitter.com/mimizunohimono)君に感謝したい。


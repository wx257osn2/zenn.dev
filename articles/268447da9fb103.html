<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="icon shortcut" href="http://localhost:8000/favicon.png"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&amp;display=swap"/><script>window.twttr=(function(f,b,g){var e,c=f.getElementsByTagName(b)[0],a=window.twttr||{};if(f.getElementById(g)){return a}e=f.createElement(b);e.id=g;e.src="https://platform.twitter.com/widgets.js";c.parentNode.insertBefore(e,c);a._e=[];a.ready=function(d){a._e.push(d)};return a}(document,"script","twitter-wjs"));</script><title>Swift Bow Archの入門のプレビュー</title><meta name="next-head-count" content="6"/><link rel="preload" href="../_next/static/css/7c32efeb1cbe6c8a3c4c.css" as="style"/><link rel="stylesheet" href="../_next/static/css/7c32efeb1cbe6c8a3c4c.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="../_next/static/chunks/main-1b66b3d4e760501de7fc.js" as="script"/><link rel="preload" href="../_next/static/chunks/webpack-c645516b0e3a28df7079.js" as="script"/><link rel="preload" href="../_next/static/chunks/framework.c81d3c1a1154ef2f0a4c.js" as="script"/><link rel="preload" href="../_next/static/chunks/commons.1d17d07e0ebe7c16f5b5.js" as="script"/><link rel="preload" href="../_next/static/chunks/pages/_app-1a997dad60d5b227663b.js" as="script"/><link rel="preload" href="../_next/static/chunks/7ea9eb72fe501167df0c2d045178d60d280aa121.549ac0d8bdc0604fb58b.js" as="script"/><link rel="preload" href="../_next/static/chunks/fac796102cd92fcc9d69418a1184140a0c3193c8.fee5f3964bb5b2c71f69.js" as="script"/><link rel="preload" href="../_next/static/chunks/pages/articles/[slug]-ed1dc9d6a24fac085414.js" as="script"/></head><body><div id="__next"><div class="main-container"><div class="main-sidebar"><aside class="sidebar"><header class="sidebar-header"><a class="sidebar-logo-link" href="http://localhost:8000/"><img src="../logo.svg" alt="Zenn Editor" width="160" height="19"/></a><a href="https://github.com/zenn-dev/zenn-editor" class="sidebar-github-link"><img src="../github.svg" alt="GitHub" width="22" height="22"/></a></header><div class="sidebar-collections"><details class="sidebar-collection" open=""><summary class="sidebar-collection__title">articles</summary><ul class="sidebar-collection__ul"><li class="sidebar-collection__li"><a class="sidebar-nav-item active" title="/articles/268447da9fb103.md" href="268447da9fb103.html">🏹 <span class="draft">下書き</span>Swift Bow Archの入門</a></li><li class="sidebar-collection__li"><a class="sidebar-nav-item " title="/articles/54134d8df9f9b5385fc3.md" href="54134d8df9f9b5385fc3.html">📄 Zennの記事をGitHub Pagesで無理やり表示する</a></li><li class="sidebar-collection__li"><a class="sidebar-nav-item " title="/articles/79c6c48226166aa0e875.md" href="79c6c48226166aa0e875.html">🙈 量子コンピュータで2人の“Covert”⁉️ガチャ</a></li><li class="sidebar-collection__li"><a class="sidebar-nav-item " title="/articles/scala-play-new-relic.md" href="scala-play-new-relic.html">📈 Scala + Play on HerokuなWebアプリにNew Relicを導入</a></li></ul></details><details class="sidebar-collection" open=""><summary class="sidebar-collection__title">books</summary><ul class="sidebar-collection__ul"><li class="sidebar-collection__li"><a class="sidebar-nav-item " title="undefined.md" href="http://localhost:8000/">✨ 最初の本を作成しましょう</a></li></ul></details></div><a href="https://zenn.dev/dashboard/uploader" class="sidebar-external-link" target="_blank" rel="noopener noreferrer"><img src="https://twemoji.maxcdn.com/2/svg/\1f4f7.svg" width="16" height="16"/>画像のアップロード</a><a href="https://zenn.dev/zenn/articles/markdown-guide" class="sidebar-external-link" target="_blank" rel="noopener noreferrer"><img src="https://twemoji.maxcdn.com/2/svg/\1f58b.svg" width="16" height="16"/>マークダウン・ガイド</a><a href="https://zenn.dev/zenn/articles/zenn-cli-guide" class="sidebar-external-link" target="_blank" rel="noopener noreferrer"><img src="https://twemoji.maxcdn.com/2/svg/\1f4bb.svg" width="16" height="16"/>CLIコマンド・ガイド</a></aside><button class="main-sidebar__minimize"><img src="../chevron.svg" alt="" width="22" height="22"/></button></div><main class="main-content"><article><div><header class="content-header"><div class="content-wrapper"><h1 class="content-header__title">Swift Bow Archの入門</h1><div class="content-header__row"><span class="content-header__row-title">slug</span><span class="content-header__row-result">268447da9fb103</span></div><div class="content-header__row"><span class="content-header__row-title">emoji</span><span class="content-header__row-result"><span style="font-size:20px">🏹</span></span></div><div class="content-header__row"><span class="content-header__row-title">topics</span><span class="content-header__row-result"><span class="content-header__topic">swift</span><span class="content-header__topic">swiftui</span><span class="content-header__topic">関数型プログラミング</span></span></div><div class="content-header__row"><span class="content-header__row-title">published</span><span class="content-header__row-result">false（下書き）</span></div><div class="content-header__row"><span class="content-header__row-title">type</span><span class="content-header__row-result">tech<!-- -->（技術記事）</span></div><a href="https://zenn.dev/zenn/articles/zenn-cli-guide" class="content-header__link" rel="noopener noreferrer" target="_blank">記事の作成方法 →</a></div></header><div class="content-wrapper"><div style="margin:40px 0"><div class="znc"><h1 id="%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB"><a class="header-anchor-link" href="268447da9fb103.html#%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB" rel="nofollow"></a> はじめに</h1>
<p>iOSDC Japan 2020の<a href="https://twitter.com/inamiy" rel="nofollow">@inamiy</a>さんの発表では、すごく雑に言って関数型なエッセンス（副作用の抽象化やLens/Prism、モナドやコモナドなど）を含むようなライブラリーとして3つが挙げられた。</p>
<ul>
<li>
<div class="embed-youtube"><iframe src="https://www.youtube.com/embed/g_hq3qfn-O8?loop=1&playlist=g_hq3qfn-O8" allowfullscreen loading="lazy"></iframe></div>
</li>
<li>
<div class="embed-speakerdeck"><iframe src="https://speakerdeck.com/player/ce7f5ecd96044bc8ac1bb5babeb87eb4" scrolling="no" allowfullscreen allow="encrypted-media" loading="lazy"></iframe></div>
</li>
</ul>
<p>今回この記事で言及する<a href="https://arch.bow-swift.io/" rel="nofollow">Bow Arch</a>はその3つのライブラリーの中の1つであり、著者が3つともを少し使ってみた限りでは現時点で一番使い勝手が気にいったので入門記事を書くこととした。@inamiyさんの発表ではBow Archが採用している<em>Comonadic UI</em>という概念や圏論といったこれらのUIライブラリーの背景にある性質にまで踏み込んで解説しており、筆者のようなSwiftはそこまで書かないが関数型プログラミングに多少興味がある人が強く引き付けられた。一方でこの圏論のような抽象的な構造は（著者のように多少は関数型プログラミングに教養があっても）非常に難しいというか抽象的なのでそれを理解しているからといって具体的なところ（UIを実装するとか）ですぐ役に立つのかが分かりずらいと思う。したがってこの記事では圏論上の対応などは可能な限り言及を避けて、なぜLens/Prismやモナド・コモナドなどを利用したUIが実際上の役に立つのか？という点をなるべく強調して説明していきたいと思う。<br>
この記事を読んで分からないことや改善点、誤りなどを見つけたら気軽にコメントなどで教えてほしい。</p>
<h1 id="%E4%BB%8A%E5%9B%9E%E3%81%A4%E3%81%8F%E3%82%8B%E3%82%82%E3%81%AE"><a class="header-anchor-link" href="268447da9fb103.html#%E4%BB%8A%E5%9B%9E%E3%81%A4%E3%81%8F%E3%82%8B%E3%82%82%E3%81%AE" rel="nofollow"></a> 今回つくるもの</h1>
<p>今回は下記の画像のように2つのスライダーを動かすと表示が変化するという極めてシンプルなUIを作成する。</p>
<p><img src="https://storage.googleapis.com/zenn-user-upload/ntt3b3oamuame7ki6fdrq4q1tipl" alt="" width="250"><br>
<em>今回つくるアプリ</em></p>
<p>この程度のアプリなら単にSwift UIでそのまま書いても全く問題とならないと思うが、簡単のために小さい例でやってみることにする。</p>
<h1 id="swift-ui-vs-comonadic-ui"><a class="header-anchor-link" href="268447da9fb103.html#swift-ui-vs-comonadic-ui" rel="nofollow"></a> Swift UI <em>vs</em> Comonadic UI</h1>
<p>そもそも実用上でBow Archやこれが採用しているComonadic UIの何が嬉しいのか？ということを明らかにするためには、Swift UIとSwift UIを素直に利用したときに利用する場合について少し理解しておく必要があると感じたので、このあたりから説明したい。</p>
<h2 id="%E3%83%8A%E3%82%A4%E3%83%BC%E3%83%96%E3%81%AAswift-ui"><a class="header-anchor-link" href="268447da9fb103.html#%E3%83%8A%E3%82%A4%E3%83%BC%E3%83%96%E3%81%AAswift-ui" rel="nofollow"></a> ナイーブなSwift UI</h2>
<p>Swift UIでは次のような<code>ObservableObject</code>に準拠し、ミュータブル（<code>var</code>）を持つようなクラス（ViewModel）をまず作っておく。</p>

      <div class="code-block-container">
        <div class="code-block-filename-container"><span class="code-block-filename">ContentViewModel.swift</span></div>
        <pre class="language-swift"><code class="language-swift"><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ContentViewModel</span><span class="token punctuation">:</span> <span class="token builtin">ObservableObject</span> <span class="token punctuation">{</span>
    @<span class="token builtin">Published</span> <span class="token keyword">var</span> coffeeBeansWeight<span class="token punctuation">:</span> <span class="token builtin">Double</span> <span class="token operator">=</span> <span class="token number">0.0</span>
<span class="token punctuation">}</span>
</code></pre>

      </div>
      <p>そして、Viewにこのミュータブルを渡して、たとえばスライダーをタップしてときに数値が更新されるようにする。</p>

      <div class="code-block-container">
        <div class="code-block-filename-container"><span class="code-block-filename">ContentView.swift</span></div>
        <pre class="language-swift"><code class="language-swift"><span class="token keyword">struct</span> <span class="token builtin">ContentView</span><span class="token punctuation">:</span> <span class="token builtin">View</span> <span class="token punctuation">{</span>
    @<span class="token builtin">ObservedObject</span> <span class="token keyword">var</span> viewModel<span class="token punctuation">:</span> <span class="token builtin">ContentViewModel</span>
    <span class="token keyword">var</span> body<span class="token punctuation">:</span> some <span class="token builtin">View</span> <span class="token punctuation">{</span>
        <span class="token builtin">VStack</span> <span class="token punctuation">{</span>
            <span class="token function">Text</span><span class="token punctuation">(</span><span class="token string">"Coffee Beans Weight: <span class="token interpolation"><span class="token delimiter variable">\(</span><span class="token function">String</span><span class="token punctuation">(</span>format<span class="token punctuation">:</span> <span class="token string">"%.1f"</span><span class="token punctuation">,</span> viewModel<span class="token punctuation">.</span>coffeeBeansWeight<span class="token punctuation">)</span><span class="token delimiter variable">)</span></span>g"</span><span class="token punctuation">)</span>
            
            <span class="token function">HStack</span><span class="token punctuation">(</span>alignment<span class="token punctuation">:</span> <span class="token punctuation">.</span>top<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">Image</span><span class="token punctuation">(</span>systemName<span class="token punctuation">:</span> <span class="token string">"minus"</span><span class="token punctuation">)</span>
                <span class="token function">Slider</span><span class="token punctuation">(</span>value<span class="token punctuation">:</span> $viewModel<span class="token punctuation">.</span>coffeeBeansWeight<span class="token punctuation">,</span> <span class="token keyword">in</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">50</span><span class="token punctuation">,</span> step<span class="token punctuation">:</span> <span class="token number">0.5</span><span class="token punctuation">)</span>
                <span class="token function">Image</span><span class="token punctuation">(</span>systemName<span class="token punctuation">:</span> <span class="token string">"plus"</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>

      </div>
      <p>こうしてViewModelとView（<code>ContentView</code>）でデータ（この例では<code>coffeeBeansWeight</code>）を操作できるようになった。例では単にViewからしかデータを変更できないので、たとえばViewModel側に次のような<code>didSet</code>を入れることで、スライダーが変更されたときに他の処理を実行することもできる。</p>

      <div class="code-block-container">
        <div class="code-block-filename-container"><span class="code-block-filename">ContentViewModel.swift</span></div>
        <pre class="language-swift"><code class="language-swift">@<span class="token builtin">Published</span> <span class="token keyword">var</span> coffeeBeansWeight<span class="token punctuation">:</span> <span class="token builtin">Double</span> <span class="token operator">=</span> <span class="token number">0.0</span> <span class="token punctuation">{</span>
    <span class="token keyword">didSet</span> <span class="token punctuation">{</span>
        <span class="token function">calculate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 何かすごい処理がおきる！</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>

      </div>
      <p>さて、このようにすれば下記のようなループによってユーザーの入力へのレスポンスとなる適切なUIが次々と生成されていくはずである。</p>
<ol>
<li>ViewModelに定義された状態をViewに渡すことで、UIからのユーザーの入力を受け取る</li>
<li>ViewModel側には<code>didSet</code>のような処理を定義されており、ユーザー入力と現在の状態から適切な次の状態へと遷移させる</li>
<li>ViewModelに定義された状態の変更をViewが検知してユーザーに適切なUIをアウトプットする</li>
</ol>
<h2 id="%E3%83%8A%E3%82%A4%E3%83%BC%E3%83%96%E3%81%AAswift-ui%E3%81%AE%E8%AA%B2%E9%A1%8C"><a class="header-anchor-link" href="268447da9fb103.html#%E3%83%8A%E3%82%A4%E3%83%BC%E3%83%96%E3%81%AAswift-ui%E3%81%AE%E8%AA%B2%E9%A1%8C" rel="nofollow"></a> ナイーブなSwift UIの課題</h2>
<p>上記で説明したようにSwift UIをそのまま使うだけであっても十分にUIを作れると思うが、一方でプログラムが次のように複雑になったり、保守性が低下する可能性があると考えている。</p>
<ul>
<li>ミュータブルな状態をViewModelとViewの両方から変更することになり、十分に状態の量が多いアプリケーションであれば、予期しない状態の変更が生じてしまい、かつそれがどこで発生したのかを特定するのが困難となりそうである</li>
<li>ViewModelで起動される関数は<code>didSet</code>の中で呼ばれることから、返り値が利用されないので事実上返り値の型は<code>Void</code>に固定される。返り値が<code>Void</code>である以上はこの中でミュータブルな状態の書き換えを生じさせるしかなく、型やインターフェースによって何をしているのか？ということを追跡できるような性質が失なわれる</li>
<li>複数ある状態を書き換えていくような仕組みをテストするよりは、引数によって確定した結果が返ってくるような関数のほうが一般的に単体テストが書きやすいと考えられる
<ul>
<li>グローバル変数があちこちに定義されていて、そのグローバル変数によって特定の挙動をしたうえでグローバル変数を書き換えて<code>Void</code>を返すような関数<code>f: Void -&gt; Void</code>よりも、<code>g: String -&gt; Int?</code>のような引数だけを使って結果が確定する関数<code>g</code>の方が単体テストしやすそうだというのはある程度一般的だと考えている</li>
</ul>
</li>
<li>筆者の予想になってしまうが、async/awaitといった平行・並列の強化によってミュータブル状態の変更がよりシビアになるのではないかと思う。具体的にはデッドロックやレースコンディションといった他のスレッド実行による問題を意識する必要が生じたときに、このようなミュータブル状態の変更は見つけにくいバグへと発展する可能性がある
<ul>
<li>async/awaitは、筆者の理解では（1）別スレッドで実行して結果を待たない<code>async</code>と、（2）<code>async</code>で実行しておいた処理を必要なときに同期する<code>await</code>の2つがあれば、実はミュータブルな状態をスレッド間で共有しなくてもユーザーが望む大抵の処理が書けてしまい、かつ状態の共有をしないためレースコンディションといった分かりにくい問題が発生しにくいものと思っている</li>
</ul>
</li>
</ul>
<p>これらの課題は、ほとんどが<a href="https://redux.js.org/understanding/thinking-in-redux/three-principles" rel="nofollow">Reduxの三原則（Three Principles）</a>で禁止されていることに該当していると個人的に思っており、著者はReact + Reduxの経験はほとんどないが過去にjQueryなどでDOMを状態としたプログラムを書いていた経験やサーバーサイドプログラミングの経験から言っても、このようなミュータブルの利用は長期間メンテナンスするということに向いていないと思っている。</p>
<h2 id="comonadic-ui%E3%81%A8%E3%81%AF"><a class="header-anchor-link" href="268447da9fb103.html#comonadic-ui%E3%81%A8%E3%81%AF" rel="nofollow"></a> Comonadic UIとは</h2>
<p>Reactを利用した説明となってしまうが、<code>useState</code>などの関数を専用のデータ構造にしたということで、（実用上は）そこまでの違いがないのではないかと思っている。たとえば下記のコードは<a href="https://zenn.dev/kazuma1989/articles/68c2339e056530">@kazuma1989さんの記事</a>からReactのコードを引用したものである。</p>

      <div class="code-block-container">
        <div class="code-block-filename-container"><span class="code-block-filename">App.tsx</span></div>
        <pre class="language-ts"><code class="language-ts"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">></span>
      <span class="token operator">&lt;</span>p<span class="token operator">></span>今のカウント<span class="token operator">:</span> <span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">></span>

      <span class="token operator">&lt;</span>button
        onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
          <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">=></span> v <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">}</span>
      <span class="token operator">></span>
        カウントアップ
      <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>

      </div>
      <p>これは<code>カウントアップ</code>ボタンを押すと表示された<code>今のカウント</code>が1つずつ増加していくプログラムとなっている。上のコードをSwift UI風に書くと次のようになる。</p>

      <div class="code-block-container">
        
        <pre class="language-swift"><code class="language-swift"><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token builtin">count</span><span class="token punctuation">,</span> setCount<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

<span class="token builtin">VStack</span> <span class="token punctuation">{</span>
    <span class="token function">Text</span><span class="token punctuation">(</span>"今のカウント<span class="token punctuation">:</span> \<span class="token punctuation">(</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>"<span class="token punctuation">)</span>
    <span class="token function">Button</span><span class="token punctuation">(</span>action<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        setCount <span class="token punctuation">{</span> <span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token keyword">in</span>
            s <span class="token operator">+</span> <span class="token number">1</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> label<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        <span class="token function">Text</span><span class="token punctuation">(</span><span class="token string">"カウントアップ"</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">font</span><span class="token punctuation">(</span><span class="token builtin">Font</span><span class="token punctuation">.</span><span class="token function">system</span><span class="token punctuation">(</span>size<span class="token punctuation">:</span> <span class="token number">14</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bold</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>

      </div>
      <p>今、<code>useState(0)</code>により初期値として<code>0</code>となるような状態<code>count</code>と、それをアップデートするための関数<code>setCount</code>が与えられた。したがって<code>useState</code>はSwiftで次のような型が付くはずである。</p>

      <div class="code-block-container">
        
        <pre class="language-swift"><code class="language-swift"><span class="token keyword">func</span> useState<span class="token operator">&lt;</span>A<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">_</span> <span class="token keyword">init</span><span class="token punctuation">:</span> A<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> A<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> A<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Void</span><span class="token punctuation">)</span>
</code></pre>

      </div>
      <p>このとき<code>setCount</code>の引数の型は<code>A -&gt; A</code>という関数になっていることがポイントである。<code>setCount</code>は現在の値を引数として次の状態を得るような関数を引数に取る高階関数となっている。前節で述べたようにナイーブなSwift UIでは状態のアップデートは何か型<code>A</code>を引数に取ることはできても、変更は状態に代入するという返り値がない操作で行うため、最終的な返り値は<code>Void</code>となるような<code>A -&gt; Void</code>であった。一方でReactのコードではアップデートがこのように古い値から新しい値を新たに生成する方法となった。これによって次のような良いことがある。</p>
<ul>
<li>新しい方法を生成するため、<code>setCount</code>にユーザーが渡す関数内ではミュータブルを伴う代入が発生しない</li>
<li>たとえばこの<code>setCount</code>に渡す関数である<code>(v: Int) in { v + 1 }</code>にテストを与えて適切なアップデートとなっているか？といったことを検査するのも状態を代入で更新しているコードよりは容易となりそうである</li>
<li>更新の際にアクセスする変数が限定されているため他の実装によって挙動が変わるといったこともない</li>
</ul>
<p>Reactではこれをこのまま使うためには他にも考えることがあるということでReduxのようなより進んだ仕組みが導入された。一方でComonadic UIはReduxとは別のアプローチでこのような恩恵をより洗練された型で受けとろうとしている。</p>
<h1 id="bow-arch%E3%81%8C%E5%88%A9%E7%94%A8%E3%81%99%E3%82%8B%E6%8A%80%E8%A1%93"><a class="header-anchor-link" href="268447da9fb103.html#bow-arch%E3%81%8C%E5%88%A9%E7%94%A8%E3%81%99%E3%82%8B%E6%8A%80%E8%A1%93" rel="nofollow"></a> Bow Archが利用する技術</h1>
<p>Swift UIとは別のUIライブラリーであるReactの例をこの後も（なるべくReactの知識がなくても理解できる範囲で）利用しつつ、ここからはBow Archがどのような抽象化をしているのかについて述べていく。</p>
<h2 id="lens"><a class="header-anchor-link" href="268447da9fb103.html#lens" rel="nofollow"></a> Lens</h2>
<p>ReactではSwift風に下記のような返り値の型が付くような関数<code>useState</code>を紹介した。</p>

      <div class="code-block-container">
        
        <pre class="language-swift"><code class="language-swift"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> A<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> A<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Void</span><span class="token punctuation">)</span>
</code></pre>

      </div>
      <p>この関数はタプルで結果を返すが、よく見るこれは左が<code>() -&gt; A</code>となるようなGetterであり、右は現在の状態を使って次の状態を設定するSetterと考えて次のようにラベルをつけると分かりやすくなる。</p>

      <div class="code-block-container">
        
        <pre class="language-swift"><code class="language-swift"><span class="token keyword">func</span> useState<span class="token operator">&lt;</span>A<span class="token operator">></span><span class="token punctuation">(</span>
    <span class="token number">_</span> <span class="token keyword">init</span><span class="token punctuation">:</span> A
<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">(</span>getter<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> A<span class="token punctuation">,</span> setter<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> A<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Void</span><span class="token punctuation">)</span>
</code></pre>

      </div>
      <p>このようにタプルのまま利用することもできるが、端的な特徴としてLensとはこのタプルに名前をつけたものである。型パラメーターがたくさんあることについてはあとで解説する。</p>

      <div class="code-block-container">
        <div class="code-block-filename-container"><span class="code-block-filename">Lens.swift</span></div>
        <pre class="language-swift"><code class="language-swift"><span class="token keyword">public</span> <span class="token keyword">typealias</span> <span class="token builtin">Lens</span><span class="token operator">&lt;</span>S<span class="token punctuation">,</span> A<span class="token operator">></span> <span class="token operator">=</span> <span class="token builtin">PLens</span><span class="token operator">&lt;</span>S<span class="token punctuation">,</span> S<span class="token punctuation">,</span> A<span class="token punctuation">,</span> A<span class="token operator">></span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PLens</span><span class="token operator">&lt;</span>S<span class="token punctuation">,</span> T<span class="token punctuation">,</span> A<span class="token punctuation">,</span> B<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">let</span> getFunc<span class="token punctuation">:</span> <span class="token punctuation">(</span>S<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> A
    <span class="token keyword">private</span> <span class="token keyword">let</span> setFunc<span class="token punctuation">:</span> <span class="token punctuation">(</span>S<span class="token punctuation">,</span> B<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> T
<span class="token punctuation">}</span>
</code></pre>

      </div>
      <p><a href="https://github.com/bow-swift/bow/blob/master/Sources/BowOptics/Lens.swift" rel="nofollow">Bowの<code>Lens.swift</code></a>ではさらなる抽象化のために元となる実装<code>PLens</code>を使って定義されているが、<code>T = S</code>かつ<code>B = A</code>なため、次のようになる。</p>

      <div class="code-block-container">
        
        <pre class="language-swift"><code class="language-swift"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Lens</span><span class="token operator">&lt;</span>S<span class="token punctuation">,</span> A<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">let</span> getFunc<span class="token punctuation">:</span> <span class="token punctuation">(</span>S<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> A
    <span class="token keyword">private</span> <span class="token keyword">let</span> setFunc<span class="token punctuation">:</span> <span class="token punctuation">(</span>S<span class="token punctuation">,</span> A<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> S
<span class="token punctuation">}</span>
</code></pre>

      </div>
      <p>ただし、ここでは型パラメーターが2つ存在している。型パラメーター<code>A</code>は実際に取り扱いたい値の型として、型パラメーター<code>S</code>はいったい何を意味しているかというと、これは型と型の包含関係を意図している。これを説明するために次のような構造体を定義する。</p>

      <div class="code-block-container">
        
        <pre class="language-swift"><code class="language-swift"><span class="token keyword">struct</span> <span class="token builtin">CoffeeBeansWeightState</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> value<span class="token punctuation">:</span> <span class="token builtin">Double</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token builtin">FirstBoiledWaterAmountState</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> value<span class="token punctuation">:</span> <span class="token builtin">Double</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token builtin">ContentState</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> coffeeBeansWeightState<span class="token punctuation">:</span> <span class="token builtin">CoffeeBeansWeightState</span>
    
    <span class="token keyword">let</span> firstBoiledWaterAmountState<span class="token punctuation">:</span> <span class="token builtin">FirstBoiledWaterAmountState</span>
<span class="token punctuation">}</span>
</code></pre>

      </div>
      <p>このような2つの構造体をフィールドに持つ構造体<code>ContentState</code>があるとする。これは図のように依存関係がある。</p>
<p><img src="https://storage.googleapis.com/zenn-user-upload/fl266d51fdd7o86jgf7it7hvgivh" alt=""><br>
<em>図1. <a href="https://www.overleaf.com/project/6037ac9ac6868c3002e38e09" rel="nofollow">https://www.overleaf.com/project/6037ac9ac6868c3002e38e09</a></em></p>
<p>そして、今この<code>ContentState</code>とフィールドの<code>CoffeeBeansWeightState</code>と<code>FirstBoiledWaterAmountState</code>の間には次のようなことが言える。</p>
<ul>
<li><code>ContentState</code>はフィールド<code>coffeeBeansWeightState</code>として<code>CoffeeBeansWeightState</code>型の値を持つので、<code>ContentState</code>な値から<code>CoffeeBeansWeightState</code>と<code>FirstBoiledWaterAmountState</code>な値が取りだせる（<em>Get</em>）</li>
<li><code>coffeeBeansWeightState</code>または<code>firstBoiledWaterAmountState</code>へ変更があった場合には、<code>ContentState</code>な値への適切な変更が必要である（<em>Set</em>）</li>
</ul>
<p><code>useState</code>はあくまでも1つの型をSetしたりGetするのみであったが、多くの場合データ構造はこの<code>ContentState</code>のように他のデータ構造をフィールドに持っている。したがってそのような依存するデータ構造との関係も記述できるようにしたのが<code>Lens&lt;S, A&gt;</code>である。<br>
今<code>Lens&lt;ContentState, CoffeeBeansWeightState&gt;</code>と書いたときには、上記の図（1）の矢印のように<embed-katex><eq class="zenn-katex">\texttt{ContentState} \rightarrow \texttt{CoffeeBeansWeightState}</eq></embed-katex>の依存を示している。<code>Lens&lt;ContentState, CoffeeBeansWeightState&gt;</code>を具体的に実装すると次のようになる。</p>

      <div class="code-block-container">
        <div class="code-block-filename-container"><span class="code-block-filename">CoffeeBeansWeightState.swift</span></div>
        <pre class="language-swift"><code class="language-swift"><span class="token keyword">extension</span> <span class="token builtin">CoffeeBeansWeightState</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">let</span> contentStateLens <span class="token operator">=</span> <span class="token builtin">Lens</span><span class="token operator">&lt;</span><span class="token builtin">ContentState</span><span class="token punctuation">,</span> <span class="token builtin">CoffeeBeansWeightState</span><span class="token operator">></span><span class="token punctuation">(</span>
        <span class="token keyword">get</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> contentState <span class="token keyword">in</span> contentState<span class="token punctuation">.</span>coffeeBeansWeightState <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token keyword">set</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> contentState<span class="token punctuation">,</span> newCoffeeBeansWeightState <span class="token keyword">in</span>
            <span class="token keyword">return</span> <span class="token function">ContentState</span><span class="token punctuation">(</span>
                coffeeBeansWeightState<span class="token punctuation">:</span> newCoffeeBeansWeightState<span class="token punctuation">,</span>
                firstBoiledWaterAmountState<span class="token punctuation">:</span> contentState<span class="token punctuation">.</span>firstBoiledWaterAmountState
            <span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>

      </div>
      <ul>
<li>まず<code>get</code>では<code>contentState</code>の<code>coffeeBeansWeightState</code>フィールドへアクセスしそれを返す</li>
<li>そして<code>set</code>では現在の<code>contentState</code>とあたらしい<code>CoffeeBeansWeightState</code>型の値からフィールド<code>.coffeeBeansWeightState</code>を更新する</li>
</ul>
<p><code>Lens&lt;ContentState, FirstBoiledWaterAmountState&gt;</code>も同様に書くことができる。<br>
<code>useState</code>のような1つの型に対する更新処理ではなくて、このような2つ型の間にある関係を記述することによって次のようなメリットがある。</p>
<ul>
<li>UIでは全ての画面を更新せずに狙った部分だけを適切に<strong>差分更新</strong>することでUXが良くなると考えられる。上記の例のようにある型が持つフィールドに変更があった時に、どの部分を更新する必要がありどの部分は更新しなくてよいのか？という情報を持つことで差分更新がやりやすくなる
<ul>
<li>筆者の知る限り、現在のBow Archでは差分更新はまだしていないと思われるので、これは今後のBow Archの改造次第では（アプリのコードを一切いじることなく）差分更新になる可能性があるというような話となる</li>
</ul>
</li>
<li>構造体<code>ContentState</code>をフィールドに持つような型が今後表れた場合に、既存の<code>Lens</code>を再利用することができる
<ul>
<li>もし型ごとに更新の木構造を記述しなければならないとすると、同じようなコードが増えてしまう</li>
</ul>
</li>
</ul>
<p>このような差分更新のテクニックはReactにも存在する。Bow ArchではGetter/Setterに差分更新に将来使えるような情報も組み込んだというふうに考えてよいと思う。</p>
<h2 id="prism"><a class="header-anchor-link" href="268447da9fb103.html#prism" rel="nofollow"></a> Prism</h2>
<p>さてGetter/Setterを得たので、次は「どのような時にSetterを起動するか？」というような処理を記述する必要がある。Lensに近い概念としてReactの<code>useState</code>があったが、Reactにある<code>useReducer</code>に近い概念として<code>Prism</code>がある。<code>useReducer</code>はSwift風に書くと次のようなインターフェースを持つ関数である。</p>

      <div class="code-block-container">
        
        <pre class="language-swift"><code class="language-swift"><span class="token keyword">func</span> useReducer<span class="token operator">&lt;</span>S<span class="token punctuation">,</span> A<span class="token operator">></span><span class="token punctuation">(</span>
  f<span class="token punctuation">:</span> <span class="token punctuation">(</span>S<span class="token punctuation">,</span> A<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> S<span class="token punctuation">,</span>
  initState<span class="token punctuation">:</span> S
<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">(</span>getter<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> S<span class="token punctuation">,</span> dispatch<span class="token punctuation">:</span> <span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Void</span><span class="token punctuation">)</span>
</code></pre>

      </div>
      <p>これまでのLensでは取得や変更の方法を与えることはできたが、どういうときにどう変更すればよいかというのはLensの範囲外である。そこを担当する。ただ、ちょっとこのあたりはReactとは別の抽象化となっているので、まずは概念を図で整理する<sup class="footnote-ref"><a href="268447da9fb103.html#fn1" id="fnref1">[1]</a></sup>。</p>
<p><img src="https://storage.googleapis.com/zenn-user-upload/j0ahultjy0alvljk7jiusba6xxmz" alt=""><br>
<em>図2. <a href="https://www.overleaf.com/project/603b82ed54755f26ad18edc0" rel="nofollow">https://www.overleaf.com/project/603b82ed54755f26ad18edc0</a></em></p>
<p>このようにPrismに関してはLensのように、Reactにある機能を単純に型の間にある関係という点で抽象化したというものではなく、Reactのよく知られた関数でPrismに相当するものはないと思う。直感的な説明をすると「<code>useReducer</code>から<code>useState</code>に相当する機能を取り去った」ような機能となっている。Bow Archではこのように1から<code>useReducer</code>に相当する機能を書くのではなくて、さきほど実装した型間のGetter/SetterとなるLensとこれから紹介するPrismの2つからほぼ自動的に<code>useReducer</code>を作るというアプローチが採用されている。</p>
<h1 id="%E6%AE%8B%E9%AA%B8"><a class="header-anchor-link" href="268447da9fb103.html#%E6%AE%8B%E9%AA%B8" rel="nofollow"></a> 残骸</h1>
<p>型パラメーター<code>S</code>は状態を表し、型パラメーター<code>A</code>は<strong>アクション</strong>の種類を表す型で、これの値によって<code>S</code>をアップデートするか？というのを<code>f</code>として与える。</p>
<p>Hello GitHub integration</p>
<section class="footnotes">
<div class="footnotes-title"><img src="https://twemoji.maxcdn.com/2/svg/1f58b.svg" class="emoji footnotes-twemoji" loading="lazy" width="20" height="20">脚注</div>
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><code>StateDispatcher</code>についてはまだ説明していないので、分からなくても大丈夫である。 <a href="268447da9fb103.html#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
</div></div></div></div></article></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"slug":"268447da9fb103","content":"\u003ch1 id=\"%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB\"\u003e\u003ca class=\"header-anchor-link\" href=\"#%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB\" rel=\"nofollow\"\u003e\u003c/a\u003e はじめに\u003c/h1\u003e\n\u003cp\u003eiOSDC Japan 2020の\u003ca href=\"https://twitter.com/inamiy\" rel=\"nofollow\"\u003e@inamiy\u003c/a\u003eさんの発表では、すごく雑に言って関数型なエッセンス（副作用の抽象化やLens/Prism、モナドやコモナドなど）を含むようなライブラリーとして3つが挙げられた。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cdiv class=\"embed-youtube\"\u003e\u003ciframe src=\"https://www.youtube.com/embed/g_hq3qfn-O8?loop=1\u0026playlist=g_hq3qfn-O8\" allowfullscreen loading=\"lazy\"\u003e\u003c/iframe\u003e\u003c/div\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cdiv class=\"embed-speakerdeck\"\u003e\u003ciframe src=\"https://speakerdeck.com/player/ce7f5ecd96044bc8ac1bb5babeb87eb4\" scrolling=\"no\" allowfullscreen allow=\"encrypted-media\" loading=\"lazy\"\u003e\u003c/iframe\u003e\u003c/div\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e今回この記事で言及する\u003ca href=\"https://arch.bow-swift.io/\" rel=\"nofollow\"\u003eBow Arch\u003c/a\u003eはその3つのライブラリーの中の1つであり、著者が3つともを少し使ってみた限りでは現時点で一番使い勝手が気にいったので入門記事を書くこととした。@inamiyさんの発表ではBow Archが採用している\u003cem\u003eComonadic UI\u003c/em\u003eという概念や圏論といったこれらのUIライブラリーの背景にある性質にまで踏み込んで解説しており、筆者のようなSwiftはそこまで書かないが関数型プログラミングに多少興味がある人が強く引き付けられた。一方でこの圏論のような抽象的な構造は（著者のように多少は関数型プログラミングに教養があっても）非常に難しいというか抽象的なのでそれを理解しているからといって具体的なところ（UIを実装するとか）ですぐ役に立つのかが分かりずらいと思う。したがってこの記事では圏論上の対応などは可能な限り言及を避けて、なぜLens/Prismやモナド・コモナドなどを利用したUIが実際上の役に立つのか？という点をなるべく強調して説明していきたいと思う。\u003cbr\u003e\nこの記事を読んで分からないことや改善点、誤りなどを見つけたら気軽にコメントなどで教えてほしい。\u003c/p\u003e\n\u003ch1 id=\"%E4%BB%8A%E5%9B%9E%E3%81%A4%E3%81%8F%E3%82%8B%E3%82%82%E3%81%AE\"\u003e\u003ca class=\"header-anchor-link\" href=\"#%E4%BB%8A%E5%9B%9E%E3%81%A4%E3%81%8F%E3%82%8B%E3%82%82%E3%81%AE\" rel=\"nofollow\"\u003e\u003c/a\u003e 今回つくるもの\u003c/h1\u003e\n\u003cp\u003e今回は下記の画像のように2つのスライダーを動かすと表示が変化するという極めてシンプルなUIを作成する。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://storage.googleapis.com/zenn-user-upload/ntt3b3oamuame7ki6fdrq4q1tipl\" alt=\"\" width=\"250\"\u003e\u003cbr\u003e\n\u003cem\u003e今回つくるアプリ\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eこの程度のアプリなら単にSwift UIでそのまま書いても全く問題とならないと思うが、簡単のために小さい例でやってみることにする。\u003c/p\u003e\n\u003ch1 id=\"swift-ui-vs-comonadic-ui\"\u003e\u003ca class=\"header-anchor-link\" href=\"#swift-ui-vs-comonadic-ui\" rel=\"nofollow\"\u003e\u003c/a\u003e Swift UI \u003cem\u003evs\u003c/em\u003e Comonadic UI\u003c/h1\u003e\n\u003cp\u003eそもそも実用上でBow Archやこれが採用しているComonadic UIの何が嬉しいのか？ということを明らかにするためには、Swift UIとSwift UIを素直に利用したときに利用する場合について少し理解しておく必要があると感じたので、このあたりから説明したい。\u003c/p\u003e\n\u003ch2 id=\"%E3%83%8A%E3%82%A4%E3%83%BC%E3%83%96%E3%81%AAswift-ui\"\u003e\u003ca class=\"header-anchor-link\" href=\"#%E3%83%8A%E3%82%A4%E3%83%BC%E3%83%96%E3%81%AAswift-ui\" rel=\"nofollow\"\u003e\u003c/a\u003e ナイーブなSwift UI\u003c/h2\u003e\n\u003cp\u003eSwift UIでは次のような\u003ccode\u003eObservableObject\u003c/code\u003eに準拠し、ミュータブル（\u003ccode\u003evar\u003c/code\u003e）を持つようなクラス（ViewModel）をまず作っておく。\u003c/p\u003e\n\n      \u003cdiv class=\"code-block-container\"\u003e\n        \u003cdiv class=\"code-block-filename-container\"\u003e\u003cspan class=\"code-block-filename\"\u003eContentViewModel.swift\u003c/span\u003e\u003c/div\u003e\n        \u003cpre class=\"language-swift\"\u003e\u003ccode class=\"language-swift\"\u003e\u003cspan class=\"token keyword\"\u003efinal\u003c/span\u003e \u003cspan class=\"token keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eContentViewModel\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token builtin\"\u003eObservableObject\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    @\u003cspan class=\"token builtin\"\u003ePublished\u003c/span\u003e \u003cspan class=\"token keyword\"\u003evar\u003c/span\u003e coffeeBeansWeight\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token builtin\"\u003eDouble\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token number\"\u003e0.0\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\n      \u003c/div\u003e\n      \u003cp\u003eそして、Viewにこのミュータブルを渡して、たとえばスライダーをタップしてときに数値が更新されるようにする。\u003c/p\u003e\n\n      \u003cdiv class=\"code-block-container\"\u003e\n        \u003cdiv class=\"code-block-filename-container\"\u003e\u003cspan class=\"code-block-filename\"\u003eContentView.swift\u003c/span\u003e\u003c/div\u003e\n        \u003cpre class=\"language-swift\"\u003e\u003ccode class=\"language-swift\"\u003e\u003cspan class=\"token keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"token builtin\"\u003eContentView\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token builtin\"\u003eView\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    @\u003cspan class=\"token builtin\"\u003eObservedObject\u003c/span\u003e \u003cspan class=\"token keyword\"\u003evar\u003c/span\u003e viewModel\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token builtin\"\u003eContentViewModel\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003evar\u003c/span\u003e body\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e some \u003cspan class=\"token builtin\"\u003eView\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"token builtin\"\u003eVStack\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n            \u003cspan class=\"token function\"\u003eText\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e\"Coffee Beans Weight: \u003cspan class=\"token interpolation\"\u003e\u003cspan class=\"token delimiter variable\"\u003e\\(\u003c/span\u003e\u003cspan class=\"token function\"\u003eString\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eformat\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token string\"\u003e\"%.1f\"\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e viewModel\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003ecoffeeBeansWeight\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token delimiter variable\"\u003e)\u003c/span\u003e\u003c/span\u003eg\"\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n            \n            \u003cspan class=\"token function\"\u003eHStack\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ealignment\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003etop\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n                \u003cspan class=\"token function\"\u003eImage\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003esystemName\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token string\"\u003e\"minus\"\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n                \u003cspan class=\"token function\"\u003eSlider\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003evalue\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e $viewModel\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003ecoffeeBeansWeight\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token keyword\"\u003ein\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e0\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token number\"\u003e50\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e step\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e0.5\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n                \u003cspan class=\"token function\"\u003eImage\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003esystemName\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token string\"\u003e\"plus\"\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n            \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\t\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\n      \u003c/div\u003e\n      \u003cp\u003eこうしてViewModelとView（\u003ccode\u003eContentView\u003c/code\u003e）でデータ（この例では\u003ccode\u003ecoffeeBeansWeight\u003c/code\u003e）を操作できるようになった。例では単にViewからしかデータを変更できないので、たとえばViewModel側に次のような\u003ccode\u003edidSet\u003c/code\u003eを入れることで、スライダーが変更されたときに他の処理を実行することもできる。\u003c/p\u003e\n\n      \u003cdiv class=\"code-block-container\"\u003e\n        \u003cdiv class=\"code-block-filename-container\"\u003e\u003cspan class=\"code-block-filename\"\u003eContentViewModel.swift\u003c/span\u003e\u003c/div\u003e\n        \u003cpre class=\"language-swift\"\u003e\u003ccode class=\"language-swift\"\u003e@\u003cspan class=\"token builtin\"\u003ePublished\u003c/span\u003e \u003cspan class=\"token keyword\"\u003evar\u003c/span\u003e coffeeBeansWeight\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token builtin\"\u003eDouble\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token number\"\u003e0.0\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003edidSet\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"token function\"\u003ecalculate\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token comment\"\u003e// 何かすごい処理がおきる！\u003c/span\u003e\n    \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\n      \u003c/div\u003e\n      \u003cp\u003eさて、このようにすれば下記のようなループによってユーザーの入力へのレスポンスとなる適切なUIが次々と生成されていくはずである。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eViewModelに定義された状態をViewに渡すことで、UIからのユーザーの入力を受け取る\u003c/li\u003e\n\u003cli\u003eViewModel側には\u003ccode\u003edidSet\u003c/code\u003eのような処理を定義されており、ユーザー入力と現在の状態から適切な次の状態へと遷移させる\u003c/li\u003e\n\u003cli\u003eViewModelに定義された状態の変更をViewが検知してユーザーに適切なUIをアウトプットする\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"%E3%83%8A%E3%82%A4%E3%83%BC%E3%83%96%E3%81%AAswift-ui%E3%81%AE%E8%AA%B2%E9%A1%8C\"\u003e\u003ca class=\"header-anchor-link\" href=\"#%E3%83%8A%E3%82%A4%E3%83%BC%E3%83%96%E3%81%AAswift-ui%E3%81%AE%E8%AA%B2%E9%A1%8C\" rel=\"nofollow\"\u003e\u003c/a\u003e ナイーブなSwift UIの課題\u003c/h2\u003e\n\u003cp\u003e上記で説明したようにSwift UIをそのまま使うだけであっても十分にUIを作れると思うが、一方でプログラムが次のように複雑になったり、保守性が低下する可能性があると考えている。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eミュータブルな状態をViewModelとViewの両方から変更することになり、十分に状態の量が多いアプリケーションであれば、予期しない状態の変更が生じてしまい、かつそれがどこで発生したのかを特定するのが困難となりそうである\u003c/li\u003e\n\u003cli\u003eViewModelで起動される関数は\u003ccode\u003edidSet\u003c/code\u003eの中で呼ばれることから、返り値が利用されないので事実上返り値の型は\u003ccode\u003eVoid\u003c/code\u003eに固定される。返り値が\u003ccode\u003eVoid\u003c/code\u003eである以上はこの中でミュータブルな状態の書き換えを生じさせるしかなく、型やインターフェースによって何をしているのか？ということを追跡できるような性質が失なわれる\u003c/li\u003e\n\u003cli\u003e複数ある状態を書き換えていくような仕組みをテストするよりは、引数によって確定した結果が返ってくるような関数のほうが一般的に単体テストが書きやすいと考えられる\n\u003cul\u003e\n\u003cli\u003eグローバル変数があちこちに定義されていて、そのグローバル変数によって特定の挙動をしたうえでグローバル変数を書き換えて\u003ccode\u003eVoid\u003c/code\u003eを返すような関数\u003ccode\u003ef: Void -\u0026gt; Void\u003c/code\u003eよりも、\u003ccode\u003eg: String -\u0026gt; Int?\u003c/code\u003eのような引数だけを使って結果が確定する関数\u003ccode\u003eg\u003c/code\u003eの方が単体テストしやすそうだというのはある程度一般的だと考えている\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e筆者の予想になってしまうが、async/awaitといった平行・並列の強化によってミュータブル状態の変更がよりシビアになるのではないかと思う。具体的にはデッドロックやレースコンディションといった他のスレッド実行による問題を意識する必要が生じたときに、このようなミュータブル状態の変更は見つけにくいバグへと発展する可能性がある\n\u003cul\u003e\n\u003cli\u003easync/awaitは、筆者の理解では（1）別スレッドで実行して結果を待たない\u003ccode\u003easync\u003c/code\u003eと、（2）\u003ccode\u003easync\u003c/code\u003eで実行しておいた処理を必要なときに同期する\u003ccode\u003eawait\u003c/code\u003eの2つがあれば、実はミュータブルな状態をスレッド間で共有しなくてもユーザーが望む大抵の処理が書けてしまい、かつ状態の共有をしないためレースコンディションといった分かりにくい問題が発生しにくいものと思っている\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eこれらの課題は、ほとんどが\u003ca href=\"https://redux.js.org/understanding/thinking-in-redux/three-principles\" rel=\"nofollow\"\u003eReduxの三原則（Three Principles）\u003c/a\u003eで禁止されていることに該当していると個人的に思っており、著者はReact + Reduxの経験はほとんどないが過去にjQueryなどでDOMを状態としたプログラムを書いていた経験やサーバーサイドプログラミングの経験から言っても、このようなミュータブルの利用は長期間メンテナンスするということに向いていないと思っている。\u003c/p\u003e\n\u003ch2 id=\"comonadic-ui%E3%81%A8%E3%81%AF\"\u003e\u003ca class=\"header-anchor-link\" href=\"#comonadic-ui%E3%81%A8%E3%81%AF\" rel=\"nofollow\"\u003e\u003c/a\u003e Comonadic UIとは\u003c/h2\u003e\n\u003cp\u003eReactを利用した説明となってしまうが、\u003ccode\u003euseState\u003c/code\u003eなどの関数を専用のデータ構造にしたということで、（実用上は）そこまでの違いがないのではないかと思っている。たとえば下記のコードは\u003ca href=\"https://zenn.dev/kazuma1989/articles/68c2339e056530\"\u003e@kazuma1989さんの記事\u003c/a\u003eからReactのコードを引用したものである。\u003c/p\u003e\n\n      \u003cdiv class=\"code-block-container\"\u003e\n        \u003cdiv class=\"code-block-filename-container\"\u003e\u003cspan class=\"code-block-filename\"\u003eApp.tsx\u003c/span\u003e\u003c/div\u003e\n        \u003cpre class=\"language-ts\"\u003e\u003ccode class=\"language-ts\"\u003e\u003cspan class=\"token keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"token keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"token function\"\u003eApp\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"token keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003ecount\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e setCount\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token function\"\u003euseState\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token number\"\u003e0\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\n  \u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\n    \u003cspan class=\"token operator\"\u003e\u0026lt;\u003c/span\u003ediv\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e\n      \u003cspan class=\"token operator\"\u003e\u0026lt;\u003c/span\u003ep\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e今のカウント\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003ecount\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"token operator\"\u003e/\u003c/span\u003ep\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e\n\n      \u003cspan class=\"token operator\"\u003e\u0026lt;\u003c/span\u003ebutton\n        onClick\u003cspan class=\"token operator\"\u003e=\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003e\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n          \u003cspan class=\"token function\"\u003esetCount\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ev\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003e\u003c/span\u003e v \u003cspan class=\"token operator\"\u003e+\u003c/span\u003e \u003cspan class=\"token number\"\u003e1\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n        \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n      \u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e\n        カウントアップ\n      \u003cspan class=\"token operator\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"token operator\"\u003e/\u003c/span\u003ebutton\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e\n    \u003cspan class=\"token operator\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"token operator\"\u003e/\u003c/span\u003ediv\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e\n  \u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\n      \u003c/div\u003e\n      \u003cp\u003eこれは\u003ccode\u003eカウントアップ\u003c/code\u003eボタンを押すと表示された\u003ccode\u003e今のカウント\u003c/code\u003eが1つずつ増加していくプログラムとなっている。上のコードをSwift UI風に書くと次のようになる。\u003c/p\u003e\n\n      \u003cdiv class=\"code-block-container\"\u003e\n        \n        \u003cpre class=\"language-swift\"\u003e\u003ccode class=\"language-swift\"\u003e\u003cspan class=\"token keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token builtin\"\u003ecount\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e setCount\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token function\"\u003euseState\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token number\"\u003e0\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"token builtin\"\u003eVStack\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"token function\"\u003eText\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\"今のカウント\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \\\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token function\"\u003ecount\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\"\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"token function\"\u003eButton\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eaction\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n        setCount \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003es\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token builtin\"\u003eInt\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token keyword\"\u003ein\u003c/span\u003e\n            s \u003cspan class=\"token operator\"\u003e+\u003c/span\u003e \u003cspan class=\"token number\"\u003e1\u003c/span\u003e\n        \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e label\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"token function\"\u003eText\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e\"カウントアップ\"\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n            \u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003efont\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token builtin\"\u003eFont\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003esystem\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003esize\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e14\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003ebold\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\n      \u003c/div\u003e\n      \u003cp\u003e今、\u003ccode\u003euseState(0)\u003c/code\u003eにより初期値として\u003ccode\u003e0\u003c/code\u003eとなるような状態\u003ccode\u003ecount\u003c/code\u003eと、それをアップデートするための関数\u003ccode\u003esetCount\u003c/code\u003eが与えられた。したがって\u003ccode\u003euseState\u003c/code\u003eはSwiftで次のような型が付くはずである。\u003c/p\u003e\n\n      \u003cdiv class=\"code-block-container\"\u003e\n        \n        \u003cpre class=\"language-swift\"\u003e\u003ccode class=\"language-swift\"\u003e\u003cspan class=\"token keyword\"\u003efunc\u003c/span\u003e useState\u003cspan class=\"token operator\"\u003e\u0026lt;\u003c/span\u003eA\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token number\"\u003e_\u003c/span\u003e \u003cspan class=\"token keyword\"\u003einit\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e A\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e A\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eA\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e A\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e \u003cspan class=\"token builtin\"\u003eVoid\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\n      \u003c/div\u003e\n      \u003cp\u003eこのとき\u003ccode\u003esetCount\u003c/code\u003eの引数の型は\u003ccode\u003eA -\u0026gt; A\u003c/code\u003eという関数になっていることがポイントである。\u003ccode\u003esetCount\u003c/code\u003eは現在の値を引数として次の状態を得るような関数を引数に取る高階関数となっている。前節で述べたようにナイーブなSwift UIでは状態のアップデートは何か型\u003ccode\u003eA\u003c/code\u003eを引数に取ることはできても、変更は状態に代入するという返り値がない操作で行うため、最終的な返り値は\u003ccode\u003eVoid\u003c/code\u003eとなるような\u003ccode\u003eA -\u0026gt; Void\u003c/code\u003eであった。一方でReactのコードではアップデートがこのように古い値から新しい値を新たに生成する方法となった。これによって次のような良いことがある。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e新しい方法を生成するため、\u003ccode\u003esetCount\u003c/code\u003eにユーザーが渡す関数内ではミュータブルを伴う代入が発生しない\u003c/li\u003e\n\u003cli\u003eたとえばこの\u003ccode\u003esetCount\u003c/code\u003eに渡す関数である\u003ccode\u003e(v: Int) in { v + 1 }\u003c/code\u003eにテストを与えて適切なアップデートとなっているか？といったことを検査するのも状態を代入で更新しているコードよりは容易となりそうである\u003c/li\u003e\n\u003cli\u003e更新の際にアクセスする変数が限定されているため他の実装によって挙動が変わるといったこともない\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eReactではこれをこのまま使うためには他にも考えることがあるということでReduxのようなより進んだ仕組みが導入された。一方でComonadic UIはReduxとは別のアプローチでこのような恩恵をより洗練された型で受けとろうとしている。\u003c/p\u003e\n\u003ch1 id=\"bow-arch%E3%81%8C%E5%88%A9%E7%94%A8%E3%81%99%E3%82%8B%E6%8A%80%E8%A1%93\"\u003e\u003ca class=\"header-anchor-link\" href=\"#bow-arch%E3%81%8C%E5%88%A9%E7%94%A8%E3%81%99%E3%82%8B%E6%8A%80%E8%A1%93\" rel=\"nofollow\"\u003e\u003c/a\u003e Bow Archが利用する技術\u003c/h1\u003e\n\u003cp\u003eSwift UIとは別のUIライブラリーであるReactの例をこの後も（なるべくReactの知識がなくても理解できる範囲で）利用しつつ、ここからはBow Archがどのような抽象化をしているのかについて述べていく。\u003c/p\u003e\n\u003ch2 id=\"lens\"\u003e\u003ca class=\"header-anchor-link\" href=\"#lens\" rel=\"nofollow\"\u003e\u003c/a\u003e Lens\u003c/h2\u003e\n\u003cp\u003eReactではSwift風に下記のような返り値の型が付くような関数\u003ccode\u003euseState\u003c/code\u003eを紹介した。\u003c/p\u003e\n\n      \u003cdiv class=\"code-block-container\"\u003e\n        \n        \u003cpre class=\"language-swift\"\u003e\u003ccode class=\"language-swift\"\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e A\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eA\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e A\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e \u003cspan class=\"token builtin\"\u003eVoid\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\n      \u003c/div\u003e\n      \u003cp\u003eこの関数はタプルで結果を返すが、よく見るこれは左が\u003ccode\u003e() -\u0026gt; A\u003c/code\u003eとなるようなGetterであり、右は現在の状態を使って次の状態を設定するSetterと考えて次のようにラベルをつけると分かりやすくなる。\u003c/p\u003e\n\n      \u003cdiv class=\"code-block-container\"\u003e\n        \n        \u003cpre class=\"language-swift\"\u003e\u003ccode class=\"language-swift\"\u003e\u003cspan class=\"token keyword\"\u003efunc\u003c/span\u003e useState\u003cspan class=\"token operator\"\u003e\u0026lt;\u003c/span\u003eA\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\n    \u003cspan class=\"token number\"\u003e_\u003c/span\u003e \u003cspan class=\"token keyword\"\u003einit\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e A\n\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003egetter\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e A\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e setter\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eA\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e A\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e \u003cspan class=\"token builtin\"\u003eVoid\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\n      \u003c/div\u003e\n      \u003cp\u003eこのようにタプルのまま利用することもできるが、端的な特徴としてLensとはこのタプルに名前をつけたものである。型パラメーターがたくさんあることについてはあとで解説する。\u003c/p\u003e\n\n      \u003cdiv class=\"code-block-container\"\u003e\n        \u003cdiv class=\"code-block-filename-container\"\u003e\u003cspan class=\"code-block-filename\"\u003eLens.swift\u003c/span\u003e\u003c/div\u003e\n        \u003cpre class=\"language-swift\"\u003e\u003ccode class=\"language-swift\"\u003e\u003cspan class=\"token keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"token keyword\"\u003etypealias\u003c/span\u003e \u003cspan class=\"token builtin\"\u003eLens\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u0026lt;\u003c/span\u003eS\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e A\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token builtin\"\u003ePLens\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u0026lt;\u003c/span\u003eS\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e S\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e A\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e A\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e\n\n\u003cspan class=\"token keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"token keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"token class-name\"\u003ePLens\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u0026lt;\u003c/span\u003eS\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e T\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e A\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e B\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"token keyword\"\u003elet\u003c/span\u003e getFunc\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eS\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e A\n    \u003cspan class=\"token keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"token keyword\"\u003elet\u003c/span\u003e setFunc\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eS\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e B\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e T\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\n      \u003c/div\u003e\n      \u003cp\u003e\u003ca href=\"https://github.com/bow-swift/bow/blob/master/Sources/BowOptics/Lens.swift\" rel=\"nofollow\"\u003eBowの\u003ccode\u003eLens.swift\u003c/code\u003e\u003c/a\u003eではさらなる抽象化のために元となる実装\u003ccode\u003ePLens\u003c/code\u003eを使って定義されているが、\u003ccode\u003eT = S\u003c/code\u003eかつ\u003ccode\u003eB = A\u003c/code\u003eなため、次のようになる。\u003c/p\u003e\n\n      \u003cdiv class=\"code-block-container\"\u003e\n        \n        \u003cpre class=\"language-swift\"\u003e\u003ccode class=\"language-swift\"\u003e\u003cspan class=\"token keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"token keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eLens\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u0026lt;\u003c/span\u003eS\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e A\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"token keyword\"\u003elet\u003c/span\u003e getFunc\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eS\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e A\n    \u003cspan class=\"token keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"token keyword\"\u003elet\u003c/span\u003e setFunc\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eS\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e A\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e S\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\n      \u003c/div\u003e\n      \u003cp\u003eただし、ここでは型パラメーターが2つ存在している。型パラメーター\u003ccode\u003eA\u003c/code\u003eは実際に取り扱いたい値の型として、型パラメーター\u003ccode\u003eS\u003c/code\u003eはいったい何を意味しているかというと、これは型と型の包含関係を意図している。これを説明するために次のような構造体を定義する。\u003c/p\u003e\n\n      \u003cdiv class=\"code-block-container\"\u003e\n        \n        \u003cpre class=\"language-swift\"\u003e\u003ccode class=\"language-swift\"\u003e\u003cspan class=\"token keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"token builtin\"\u003eCoffeeBeansWeightState\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003elet\u003c/span\u003e value\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token builtin\"\u003eDouble\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"token keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"token builtin\"\u003eFirstBoiledWaterAmountState\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003elet\u003c/span\u003e value\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token builtin\"\u003eDouble\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"token keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"token builtin\"\u003eContentState\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003elet\u003c/span\u003e coffeeBeansWeightState\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token builtin\"\u003eCoffeeBeansWeightState\u003c/span\u003e\n    \n    \u003cspan class=\"token keyword\"\u003elet\u003c/span\u003e firstBoiledWaterAmountState\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token builtin\"\u003eFirstBoiledWaterAmountState\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\n      \u003c/div\u003e\n      \u003cp\u003eこのような2つの構造体をフィールドに持つ構造体\u003ccode\u003eContentState\u003c/code\u003eがあるとする。これは図のように依存関係がある。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://storage.googleapis.com/zenn-user-upload/fl266d51fdd7o86jgf7it7hvgivh\" alt=\"\"\u003e\u003cbr\u003e\n\u003cem\u003e図1. \u003ca href=\"https://www.overleaf.com/project/6037ac9ac6868c3002e38e09\" rel=\"nofollow\"\u003ehttps://www.overleaf.com/project/6037ac9ac6868c3002e38e09\u003c/a\u003e\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eそして、今この\u003ccode\u003eContentState\u003c/code\u003eとフィールドの\u003ccode\u003eCoffeeBeansWeightState\u003c/code\u003eと\u003ccode\u003eFirstBoiledWaterAmountState\u003c/code\u003eの間には次のようなことが言える。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eContentState\u003c/code\u003eはフィールド\u003ccode\u003ecoffeeBeansWeightState\u003c/code\u003eとして\u003ccode\u003eCoffeeBeansWeightState\u003c/code\u003e型の値を持つので、\u003ccode\u003eContentState\u003c/code\u003eな値から\u003ccode\u003eCoffeeBeansWeightState\u003c/code\u003eと\u003ccode\u003eFirstBoiledWaterAmountState\u003c/code\u003eな値が取りだせる（\u003cem\u003eGet\u003c/em\u003e）\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecoffeeBeansWeightState\u003c/code\u003eまたは\u003ccode\u003efirstBoiledWaterAmountState\u003c/code\u003eへ変更があった場合には、\u003ccode\u003eContentState\u003c/code\u003eな値への適切な変更が必要である（\u003cem\u003eSet\u003c/em\u003e）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003euseState\u003c/code\u003eはあくまでも1つの型をSetしたりGetするのみであったが、多くの場合データ構造はこの\u003ccode\u003eContentState\u003c/code\u003eのように他のデータ構造をフィールドに持っている。したがってそのような依存するデータ構造との関係も記述できるようにしたのが\u003ccode\u003eLens\u0026lt;S, A\u0026gt;\u003c/code\u003eである。\u003cbr\u003e\n今\u003ccode\u003eLens\u0026lt;ContentState, CoffeeBeansWeightState\u0026gt;\u003c/code\u003eと書いたときには、上記の図（1）の矢印のように\u003cembed-katex\u003e\u003ceq class=\"zenn-katex\"\u003e\\texttt{ContentState} \\rightarrow \\texttt{CoffeeBeansWeightState}\u003c/eq\u003e\u003c/embed-katex\u003eの依存を示している。\u003ccode\u003eLens\u0026lt;ContentState, CoffeeBeansWeightState\u0026gt;\u003c/code\u003eを具体的に実装すると次のようになる。\u003c/p\u003e\n\n      \u003cdiv class=\"code-block-container\"\u003e\n        \u003cdiv class=\"code-block-filename-container\"\u003e\u003cspan class=\"code-block-filename\"\u003eCoffeeBeansWeightState.swift\u003c/span\u003e\u003c/div\u003e\n        \u003cpre class=\"language-swift\"\u003e\u003ccode class=\"language-swift\"\u003e\u003cspan class=\"token keyword\"\u003eextension\u003c/span\u003e \u003cspan class=\"token builtin\"\u003eCoffeeBeansWeightState\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"token keyword\"\u003elet\u003c/span\u003e contentStateLens \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token builtin\"\u003eLens\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"token builtin\"\u003eContentState\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token builtin\"\u003eCoffeeBeansWeightState\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\n        \u003cspan class=\"token keyword\"\u003eget\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e contentState \u003cspan class=\"token keyword\"\u003ein\u003c/span\u003e contentState\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003ecoffeeBeansWeightState \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n        \u003cspan class=\"token keyword\"\u003eset\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e contentState\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e newCoffeeBeansWeightState \u003cspan class=\"token keyword\"\u003ein\u003c/span\u003e\n            \u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"token function\"\u003eContentState\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\n                coffeeBeansWeightState\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e newCoffeeBeansWeightState\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n                firstBoiledWaterAmountState\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e contentState\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003efirstBoiledWaterAmountState\n            \u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n        \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\n      \u003c/div\u003e\n      \u003cul\u003e\n\u003cli\u003eまず\u003ccode\u003eget\u003c/code\u003eでは\u003ccode\u003econtentState\u003c/code\u003eの\u003ccode\u003ecoffeeBeansWeightState\u003c/code\u003eフィールドへアクセスしそれを返す\u003c/li\u003e\n\u003cli\u003eそして\u003ccode\u003eset\u003c/code\u003eでは現在の\u003ccode\u003econtentState\u003c/code\u003eとあたらしい\u003ccode\u003eCoffeeBeansWeightState\u003c/code\u003e型の値からフィールド\u003ccode\u003e.coffeeBeansWeightState\u003c/code\u003eを更新する\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003eLens\u0026lt;ContentState, FirstBoiledWaterAmountState\u0026gt;\u003c/code\u003eも同様に書くことができる。\u003cbr\u003e\n\u003ccode\u003euseState\u003c/code\u003eのような1つの型に対する更新処理ではなくて、このような2つ型の間にある関係を記述することによって次のようなメリットがある。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eUIでは全ての画面を更新せずに狙った部分だけを適切に\u003cstrong\u003e差分更新\u003c/strong\u003eすることでUXが良くなると考えられる。上記の例のようにある型が持つフィールドに変更があった時に、どの部分を更新する必要がありどの部分は更新しなくてよいのか？という情報を持つことで差分更新がやりやすくなる\n\u003cul\u003e\n\u003cli\u003e筆者の知る限り、現在のBow Archでは差分更新はまだしていないと思われるので、これは今後のBow Archの改造次第では（アプリのコードを一切いじることなく）差分更新になる可能性があるというような話となる\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e構造体\u003ccode\u003eContentState\u003c/code\u003eをフィールドに持つような型が今後表れた場合に、既存の\u003ccode\u003eLens\u003c/code\u003eを再利用することができる\n\u003cul\u003e\n\u003cli\u003eもし型ごとに更新の木構造を記述しなければならないとすると、同じようなコードが増えてしまう\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eこのような差分更新のテクニックはReactにも存在する。Bow ArchではGetter/Setterに差分更新に将来使えるような情報も組み込んだというふうに考えてよいと思う。\u003c/p\u003e\n\u003ch2 id=\"prism\"\u003e\u003ca class=\"header-anchor-link\" href=\"#prism\" rel=\"nofollow\"\u003e\u003c/a\u003e Prism\u003c/h2\u003e\n\u003cp\u003eさてGetter/Setterを得たので、次は「どのような時にSetterを起動するか？」というような処理を記述する必要がある。Lensに近い概念としてReactの\u003ccode\u003euseState\u003c/code\u003eがあったが、Reactにある\u003ccode\u003euseReducer\u003c/code\u003eに近い概念として\u003ccode\u003ePrism\u003c/code\u003eがある。\u003ccode\u003euseReducer\u003c/code\u003eはSwift風に書くと次のようなインターフェースを持つ関数である。\u003c/p\u003e\n\n      \u003cdiv class=\"code-block-container\"\u003e\n        \n        \u003cpre class=\"language-swift\"\u003e\u003ccode class=\"language-swift\"\u003e\u003cspan class=\"token keyword\"\u003efunc\u003c/span\u003e useReducer\u003cspan class=\"token operator\"\u003e\u0026lt;\u003c/span\u003eS\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e A\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\n  f\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eS\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e A\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e S\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n  initState\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e S\n\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003egetter\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e S\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e dispatch\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eA\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e \u003cspan class=\"token builtin\"\u003eVoid\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\n      \u003c/div\u003e\n      \u003cp\u003eこれまでのLensでは取得や変更の方法を与えることはできたが、どういうときにどう変更すればよいかというのはLensの範囲外である。そこを担当する。ただ、ちょっとこのあたりはReactとは別の抽象化となっているので、まずは概念を図で整理する\u003csup class=\"footnote-ref\"\u003e\u003ca href=\"#fn1\" id=\"fnref1\"\u003e[1]\u003c/a\u003e\u003c/sup\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://storage.googleapis.com/zenn-user-upload/j0ahultjy0alvljk7jiusba6xxmz\" alt=\"\"\u003e\u003cbr\u003e\n\u003cem\u003e図2. \u003ca href=\"https://www.overleaf.com/project/603b82ed54755f26ad18edc0\" rel=\"nofollow\"\u003ehttps://www.overleaf.com/project/603b82ed54755f26ad18edc0\u003c/a\u003e\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eこのようにPrismに関してはLensのように、Reactにある機能を単純に型の間にある関係という点で抽象化したというものではなく、Reactのよく知られた関数でPrismに相当するものはないと思う。直感的な説明をすると「\u003ccode\u003euseReducer\u003c/code\u003eから\u003ccode\u003euseState\u003c/code\u003eに相当する機能を取り去った」ような機能となっている。Bow Archではこのように1から\u003ccode\u003euseReducer\u003c/code\u003eに相当する機能を書くのではなくて、さきほど実装した型間のGetter/SetterとなるLensとこれから紹介するPrismの2つからほぼ自動的に\u003ccode\u003euseReducer\u003c/code\u003eを作るというアプローチが採用されている。\u003c/p\u003e\n\u003ch1 id=\"%E6%AE%8B%E9%AA%B8\"\u003e\u003ca class=\"header-anchor-link\" href=\"#%E6%AE%8B%E9%AA%B8\" rel=\"nofollow\"\u003e\u003c/a\u003e 残骸\u003c/h1\u003e\n\u003cp\u003e型パラメーター\u003ccode\u003eS\u003c/code\u003eは状態を表し、型パラメーター\u003ccode\u003eA\u003c/code\u003eは\u003cstrong\u003eアクション\u003c/strong\u003eの種類を表す型で、これの値によって\u003ccode\u003eS\u003c/code\u003eをアップデートするか？というのを\u003ccode\u003ef\u003c/code\u003eとして与える。\u003c/p\u003e\n\u003cp\u003eHello GitHub integration\u003c/p\u003e\n\u003csection class=\"footnotes\"\u003e\n\u003cdiv class=\"footnotes-title\"\u003e\u003cimg src=\"https://twemoji.maxcdn.com/2/svg/1f58b.svg\" class=\"emoji footnotes-twemoji\" loading=\"lazy\" width=\"20\" height=\"20\"\u003e脚注\u003c/div\u003e\n\u003col class=\"footnotes-list\"\u003e\n\u003cli id=\"fn1\" class=\"footnote-item\"\u003e\u003cp\u003e\u003ccode\u003eStateDispatcher\u003c/code\u003eについてはまだ説明していないので、分からなくても大丈夫である。 \u003ca href=\"#fnref1\" class=\"footnote-backref\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/section\u003e\n","title":"Swift Bow Archの入門","emoji":"🏹","type":"tech","topics":["swift","swiftui","関数型プログラミング"],"published":false},"allContentsNavCollections":[{"name":"articles","items":[{"name":"🏹 \u003cspan class=\"draft\"\u003e下書き\u003c/span\u003eSwift Bow Archの入門","href":"/articles/[slug]","as":"/articles/268447da9fb103"},{"name":"📄 Zennの記事をGitHub Pagesで無理やり表示する","href":"/articles/[slug]","as":"/articles/54134d8df9f9b5385fc3"},{"name":"🙈 量子コンピュータで2人の“Covert”⁉️ガチャ","href":"/articles/[slug]","as":"/articles/79c6c48226166aa0e875"},{"name":"📈 Scala + Play on HerokuなWebアプリにNew Relicを導入","href":"/articles/[slug]","as":"/articles/scala-play-new-relic"}]},{"name":"books","items":[{"name":"✨ 最初の本を作成しましょう","href":"/"}]}]},"__N_SSP":true},"page":"/articles/[slug]","query":{"slug":"268447da9fb103"},"buildId":"uVa7KTqGK7QlXpqAQhlyH","isFallback":false,"gssp":true,"customServer":true}</script><script nomodule="" src="../_next/static/chunks/polyfills-bc93924a219b603c3b70.js"></script><script src="../_next/static/chunks/main-1b66b3d4e760501de7fc.js" async=""></script><script src="../_next/static/chunks/webpack-c645516b0e3a28df7079.js" async=""></script><script src="../_next/static/chunks/framework.c81d3c1a1154ef2f0a4c.js" async=""></script><script src="../_next/static/chunks/commons.1d17d07e0ebe7c16f5b5.js" async=""></script><script src="../_next/static/chunks/pages/_app-1a997dad60d5b227663b.js" async=""></script><script src="../_next/static/chunks/7ea9eb72fe501167df0c2d045178d60d280aa121.549ac0d8bdc0604fb58b.js" async=""></script><script src="../_next/static/chunks/fac796102cd92fcc9d69418a1184140a0c3193c8.fee5f3964bb5b2c71f69.js" async=""></script><script src="../_next/static/chunks/pages/articles/[slug]-ed1dc9d6a24fac085414.js" async=""></script><script src="../_next/static/uVa7KTqGK7QlXpqAQhlyH/_buildManifest.js" async=""></script><script src="../_next/static/uVa7KTqGK7QlXpqAQhlyH/_ssgManifest.js" async=""></script></body></html>